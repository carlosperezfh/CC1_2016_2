<!DOCTYPE html>
<!-- saved from url=(0035)http://www.zator.com/Cpp/E5_1_1.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Contenedores</title>

<link rel="stylesheet" type="text/css" href="./Contenedores_files/eztilosH.css">
<link rel="shortcut icon" href="http://www.zator.com/Cpp/images/zicon.ico">
</head>
<body>
<div class="top1">
﻿
<!-- mancheta estandar C++-->
<style>  <!-- esta zona es valida solo para desarrollo. En runtime copia el contenido de style-1 -->
 .flo { font-size:10pt; color:#880000; padding:1em; text-align:left; float:left; border:#990000 1px solid; background-color:#FFFF99; }
 li {margin-top:0pt; margin-bottom:0pt;}
</style>

<table border="0" bgcolor="#FFFFFF" cellpadding="2" cellspacing="0" width="100%"><tbody><tr>
  <td>
  <div align="left">
    <!--p class='flo'><font color='#FF0000'><B>Â¡Nuevo!</B></font>&nbsp; por fin disponible la versiÃ³n 5 de <b>OrganiZATOR</b-->
    <p class="flo">Disponible la nueva versión "<b>donationware</b>"<b> 7.3</b> de <b>OrganiZATOR</b>
    <br>Descubre un nuevo concepto en el manejo de la información.
    <br>La mejor ayuda para sobrevivir en la moderna jungla de datos la tienes <a href="http://www.zator.com/zLvd.htm">aquí</a>.</p>
  </div>
  </td>
  <td>

  <p class="n1"><font color="#0000ff" face="Arial Black" size="5"><a name="TOP">Curso C++</a></font></p>
  <div align="right">
    <table border="0" bgcolor="#CCCCCC" cellpadding="2" cellspacing="0"><tbody><tr><td>
    <p class="n1" align="right">[<a href="http://www.zator.com/index.htm">Home</a>]&nbsp; [<a href="http://www.zator.com/Cpp/index.htm">Inicio</a>]&nbsp; [<a href="http://www.zator.com/Cpp/E_Ce.htm">Índice</a>]</p></td>
    </tr></tbody></table>
  </div>
</td></tr></tbody></table></div>
<div class="ext">
<table border="0" width="100%" cellpadding="0" cellspacing="0"><tbody><tr><td valign="top">
<div class="left">
<div class="lmenu">
<p class="n2"><b>En esta sección</b>:</p>
﻿
 <p class="ibm"><a href="http://www.zator.com/Cpp/E5_1_1a.htm">a Seleccionar un contenedor</a></p>
 <p class="ibm"><a href="http://www.zator.com/Cpp/E5_1_1b.htm">b Cuestiones adicionales</a></p>
 <p class="ibm"><a href="http://www.zator.com/Cpp/E5_1_1c.htm">c Secuencias</a></p>
 <p class="ibm"><!--a href="E5_1_1d.htm"-->d Adaptadores</p>
 <p class="ibm"><a href="http://www.zator.com/Cpp/E5_1_1e.htm">e Contenedores asociativos</a></p>

<p class="ibm"><a href="http://www.zator.com/Cpp/E5_1.htm"><img border="0" src="./Contenedores_files/aUp.gif" width="16" height="16"> Subir</a></p></div><br>
<script src="./Contenedores_files/ca-pub-3633041490650355.js.descarga"></script><script type="text/javascript"><!--
google_ad_client = 'pub-3633041490650355';
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = '160x600_as';
google_ad_type = 'text_image';
google_ad_channel ='';
google_color_border = 'DDAAAA';
google_color_bg = 'ECF8FF';
google_color_link = '0033FF';
google_color_url = '0033FF';
google_color_text = '000000';
//--></script>
<script type="text/javascript" src="./Contenedores_files/show_ads.js.descarga">
</script><ins id="aswift_0_expand" style="display:inline-table;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:160px;background-color:transparent"><ins id="aswift_0_anchor" style="display:block;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:160px;background-color:transparent"><iframe width="160" height="600" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;" src="./Contenedores_files/saved_resource.html"></iframe></ins></ins>
</div>
</td><td valign="top" width="100%">
<div class="top2" align="RIGHT">
<script type="text/javascript"><!--
google_ad_client = 'pub-3633041490650355';
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = '728x90_as';
google_ad_type = 'text_image';
google_ad_channel ='';
google_color_border = 'DDAAAA';
google_color_bg = 'ECF8FF';
google_color_link = '0033FF';
google_color_url = '0033FF';
google_color_text = '000000';
//--></script>
<script type="text/javascript" src="./Contenedores_files/show_ads.js.descarga">
</script><ins id="aswift_1_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><ins id="aswift_1_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><iframe width="728" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;" src="./Contenedores_files/saved_resource(1).html"></iframe></ins></ins>
</div>
<div class="main">

<!--LM E5_1_1-->

  <h4>5.1.1 Contenedores</h4>

  <h5>§1 Presentación</h5>

<p>En sentido C++ estricto, un <b>contenedor</b> de la STL es una <span style="background-color: #FFFF00"> clase
  genérica</span> (plantilla <img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
  <a href="http://www.zator.com/Cpp/E4_12_2.htm">4.12.2</a>) que puede instanciarse para representar
  diversos tipos de objetos.&nbsp;Esta clase incluye ciertas operaciones (muy
  básicas) sobre los objetos de su tipo; naturalmente estas operaciones
  están representadas por funciones-miembro, incluyendo constructores y funciones-operador, que son a su vez funciones genéricas
  (plantillas <img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
  <a href="http://www.zator.com/Cpp/E4_12_1.htm">4.12.1</a>). Al mismo tiempo, desde el punto de vista de las teorías de la información, podemos considerarlos
  <b> estructuras de datos</b> (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
  <a href="http://www.zator.com/Cpp/E1_8.htm#Datos y algoritmos">1.8</a>) más o menos adecuadas (según
  el caso) para aplicarles ciertos algoritmos (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
  <a href="http://www.zator.com/Cpp/E5_1_3.htm">5.1.3</a>).</p>

  <p>De su propio nombre ("Containers") podemos deducir
  que su misión principal, y razón de su existencia, es su función como
  estructuras de datos, y en este sentido podemos adelantar que entre sus
  funcionalidades más destacadas se encuentran la gestión del espacio de
  almacenamiento necesario. Como veremos al tratar de los asignadores de
  memoria (allocators <img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16"> <a href="http://www.zator.com/Cpp/E5_1_5.htm">5.1.5</a>)
  y en las explicaciones más detalladas al respecto (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
  <a href="http://www.zator.com/Cpp/E5_1_1b.htm">5.1.1b</a>), una de las primerísimas ventajas de la
  utilización de contenedores es que el programador no tiene que enredarse con
  las cuestiones siempre espinosas de asignar o liberar memoria para los objetos
  creados, de forma que queda liberado de los operadores <strong>new</strong> y <strong>delete</strong>
  (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16"> <a href="http://www.zator.com/Cpp/E4_9_20.htm">4.9.20</a>).</p>

  <h5>§2 Filosofía de uso</h5>

<p>Presentaremos una primera pincelada sobre la filosofía de
  uso de los contenedores mediante un sencillo ejemplo:&nbsp;si tenemos que manejar un conjunto de enteros, puede utilizarse
  una matriz de enteros, pero ya hemos señalado (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
  <a href="http://www.zator.com/Cpp/E4_3.htm">4.3</a>) que esta estructura nos obliga a conocer de
  antemano la cantidad de datos a almacenar (el tamaño de la matriz). En
  consecuencia, si el número de datos puede variar, esta opción no es muy
  adecuada. Además, si es importante mantener los datos ordenados, la
  utilización de una matriz nos obligaría a ingeniar por nuestra cuenta la
  forma de hacerlo; seguramente mediante complicadas rutinas de "sort" hechas manualmente.</p>

  <p>Una alternativa es utilizar como "contenedor" para nuestros enteros una clase genérica de la STL
  denominada <strong>vector</strong>. En este caso, serían posibles expresiones como las siguientes:</p>

  <p class="code">vector&lt;int&gt; v(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// L1:<br>
  v[0] = 7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// L2:<br>
  v[1] = v[0] + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;// L3:<br>
  v[2] = v[0] + v[1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // L4:</p>

  <p><br>Al encontrar la primera sentencia, el compilador crea una instancia (especialidad) anónima de la plantilla <strong>vector</strong>
  para alojar enteros; a continuación una instancia de ella para alojar tres enteros, a la que denominamos <b>v</b>.</p>

  <p>Una primera inspección de las sentencias L2 a L3, nos muestra que la clase ofrece la posibilidad de utilizar con sus miembros
  el operador subíndice de matriz <strong>[ ]</strong> (<img src="./Contenedores_files/Ico_hoja.gif" border="0" width="16" height="16">
  <a href="http://www.zator.com/Cpp/E4_9_16.htm#Operador de elemento de matriz">4.9.16</a>). Deducimos por tanto, que dispone de una versión sobrecargada de
  este operador para los miembros de la clase (<img src="./Contenedores_files/Ico_hoja.gif" border="0" width="16" height="16">
  <a href="http://www.zator.com/Cpp/E4_9_18d.htm">4.9.18d</a>), lo que nos permite utilizar el objeto <b>v</b> como una matriz, aunque con algunas
  funcionalidades no incluidas en aquellas.</p>

  <p>Después de L4 los valores finales para los miembros de nuestra "matriz" serian:</p>

  <p class="code"> v[0] == 7, v[1] == 8, v[2] == 15</p>

  <p><br>Supongamos ahora que deseamos invertir el orden de los elementos de nuestra matriz. Para ello utilizamos una función
  especial:</p>

  <p class="code">reverse(v.begin(), v.end());</p>

  <p>después de lo cual, el orden de miembros sería:</p>

  <p class="code">v[0] == 15, v[1] == 8, v[2] == 7</p>

<p><br>
  La primera observación es que la función <b>reverse</b> utiliza dos
  argumentos, que son a su vez el valor devuelto por sendos métodos de clase
  (los aplicamos sobre nuestro objeto <b>v</b>).&nbsp;
  El valor devuelto por estos métodos es lo que se conoce como un <b>iterador</b>;&nbsp;una especie de puntero que señalan al interior de la estructura de datos
  representada por el contenedor <b>v</b>. En
  este caso, el primer iterador señala al primer miembro y el segundo a una
  posición después del último; de esta forma se indican los miembros inicial
  y final entre los que se realizará la operación de inversión efectuada por <b>reverse</b>.</p>

  <p>La segunda observación es que la función <b>reverse</b> <b>no</b>
  es un método de clase, sino una función global; es lo
  que denominamos un <b>algoritmo</b>. Esta
  función tiene
  la peculiaridad de que puede ser aplicado sobre el contenedor
  <b>vector</b> (y algún otro); que opera sobre un rango de los elementos
  del contenedor, en nuestro caso sobre la totalidad (esta capacidad de
  operar sobre una parte de un contenedor es característica de los algoritmos). También que pueden operar sobre otros contenedores
  produciendo un efecto similar. Por ejemplo, el algoritmo <b>reverse</b> puede operar
  incluso sobre una simple matriz:</p>

  <p class="code">char Ch[5] = { 'A', 'E', 'I', 'O', 'U' };<br>
  reverse(Ch, Ch + 5);<br>
  for (int i = 0; i &lt; 5; ++i) cout &lt;&lt; "Ch[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; Ch[i];</p>

  <p>Salida:</p>

  <p class="code">Ch[0] = U Ch[1] = O Ch[2] = I Ch[3] = E Ch[4] = A</p>

  <p><br>Es significativo que el objeto <b>v</b> es una estructura de datos que permite acceder individualmente a sus miembros
  "como si" fuesen elementos de una matriz. También que se pueden
  aplicar ciertas operaciones sobre la totalidad, o parte, de esta estructura considerada como una unidad.</p>

  <h5>§3 <a name="Clasificación">Clasificación</a></h5>

  <p>Existen dos tipos de contenedores: <b>secuencias</b> y <b>asociativos</b>; a su vez se subdividen
  según el tipo de <b>iterador</b> que soportan.</p>

  <p>Las <b>secuencias</b> almacenan los elementos en orden
  secuencial (de ahí su nombre). El contenedor agrupa a todos sus miembros como
  una sucesión lineal, y en consecuencia son adecuadas para accesos directos y
  secuenciales. Un ejemplo de secuencia es una matriz. De hecho, los
  algoritmos que pueden aplicarse a las secuencias pueden aplicarse también a las matrices.</p>

  <p>Las <b>asociaciones</b> almacenan sus miembros en forma de árbol indexado, por lo que son denominados también contenedores
  asociativos ordenados, y resultan adecuados para accesos aleatorios mediante claves.&nbsp; La STL proporciona cinco tipo distintos.</p>

  <p>La existencia de índices supone una ordenación según los valores de un conjunto de elementos (denominado "de claves")
  para el que debe existir un criterio de ordenación. Dicho en otras palabras, los objetos "de clave" deben ser de un tipo
  para el que estén definidos los operadores relacionales. El árbol es mantenido ordenado de forma automática por
  los algoritmos de inserción y borrado del contenedor.</p>

  <p>Existen mecanismos para asociar un valor o dato de cualquier tipo con una clave; para encontrar el valor asociado a una
  clave y para recorrer el conjunto (ordenado) de los elementos.</p>

  <p>La Librería Estándar C++ contiene diez formas de contenedores y tres adaptadores de contenedor (denominados
  simplemente <b>adaptadores</b>). En esta sección se expondrán brevemente cuales son estas formas; sus
  características, y cual es la más adecuada para cada tipo de problema
  específico. En secciones sucesivas se comentarán individualmente con mayor detalle.</p>

  <p>A continuación incluimos una relación siguiendo la clasificación utilizada en el Estándar:</p>

  <ul>
    <li><p class="n2"><b>Secuencias</b></p>
    <ul>
  <li><p class="n2"><strong>deque</strong></p></li>
  <li><p class="n2"><strong>list</strong></p></li>
  <li><p class="n2"><strong>stack</strong></p></li>
  <li><p class="n2"><strong>vector</strong></p></li>
  <li><p class="n2"><strong>vector &lt;bool&gt;</strong></p></li>
   </ul>
  </li><li><p class="n2"><b>adaptadores</b></p></li>
    <ul>
  <li><p class="n2"><strong>queue</strong></p></li>
  <li><p class="n2"><strong>priority_queue</strong></p></li>
    </ul>
    <li><p class="n2"><b>Contenedores asociativos</b></p>
      <ul>
  <li><p class="n2"><strong>map</strong></p></li>
  <li><p class="n2"><strong>multimap</strong></p></li>
  <li><p class="n2"><strong>set</strong></p></li>
  <li><p class="n2"><strong>multiset</strong></p></li>
  <li><p class="n2"><strong>bitset</strong></p></li>
  </ul></li>
  </ul>

  <h5>§4 <a name="Características">Características</a></h5>

  <p>Las características más significativas de las diversas formas de contenedor son:</p>

<table border="0" cellpadding="5" class="bg0"><tbody><tr>
  <td width="90" valign="top"><b>Contenedor</b></td>
  <td><b>Características</b></td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF" colspan="2"><b>Secuencias</b></td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>vector</strong></td>
  <td bgcolor="#FFFFFF">Este contenedor es una estructura de
    datos de tamaño fijo preferentemente. Aunque la STL proporciona
    herramientas para cambiar el tamaño de un vector de forma dinámica,
    esta operación es costosa y debe ser evitada dentro de lo posible (en
    este sentido el vector se comporta como una matriz ordinaria).
    <p>Disponen de un buén mecanismo de acceso aleatorio a elementos y de
    un mecanismo de inserción al final muy eficiente (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
    <a href="http://www.zator.com/Cpp/E5_1_2g.htm#Inserción al final">5.1.2g</a>).</p>
    <p>Generalmente es preferible utilizar un <b>vector</b> que un <b>deque</b>
    o un <b>list</b>, a menos que sea frecuentemente necesario insertar
    datos al comienzo o al final, en cuyo caso es mejor utilizar un <b>deque</b>.&nbsp;
    Si por el contrario es frecuente la inserción de elementos en el
    centro, entonces es preferible un <b>list</b>.</p>
  </td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>vector&lt;bool&gt;</strong></td>
  <td bgcolor="#FFFFFF">Es una versión de la anterior especial
    para valores binarios (bits).</td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>list</strong></td>
  <td bgcolor="#FFFFFF">Este contenedor responde a la idéa
    intuitiva de "lista", el almacenamiento de objetos en una
    secuencia lineal que no está necesariamente ordenada (aunque sus miembros
    pueden ser ordenados fácilmente mediante la función-miembro <b>sort</b>()
    ). Estos contenedores suelen ser implementados como listas
    doblemente enlazadas (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
    <a href="http://www.zator.com/Cpp/E1_8.htm#Listas enlazadas">1.8</a>).

    <p>Dispone de mecanismos eficientes para insertar elementos al
    principio, al final o en cualquier posición (utilizando iteradores
    que denoten posición). Estas operaciones consumen un tiempo
    constante con independencia del número de elmentos albergados en el contenedor.</p>
    <p>Dado que son estructuras lineales, en general los elementos no
    pueden ser accedidos por subíndices como en un <b>vector</b>.&nbsp;
    Es necesario realizar un recorrido lineal por todos los valores, por
    lo que en las operaciones de acceso se utilizan tiempos proporcionales
    al número de elementos.</p>
  </td>
  </tr>
  <tr>
  <td width="18%" valign="top" bgcolor="#FFFFFF"><strong>stack</strong></td>
  <td width="83%" bgcolor="#FFFFFF">Contenedor de elementos tipo pila LIFO
  que permite inserciones y eliminaciones solo en la parte superior.</td>
  </tr>
  <tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>deque</strong></td>
  <td bgcolor="#FFFFFF"> Los <b>deques</b>
    o colas de doble terminación ("Double-ended queue") son un
    tipo de estructura de datos que comparte las características de las colas
    ("Queues") y las pilas
    ("Stacks"). Como en las colas (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
    <a href="http://www.zator.com/Cpp/E1_8.htm#Colas:">1.8</a>), los elementos pueden ser empujados
    por un extremo al interior del contenedor, y el primer elemento
    introducido puede ser extraído por el extremo opuesto. Al mismo
    tiempo, el último elemento introducido por el principio puede ser extraído
    en ese mismo extremo como si fuese una pila (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16">
    <a href="http://www.zator.com/Cpp/E1_8.htm#Pilas:">1.8</a>).
    <p>Estos contenedores suelen ser implementados bajo la forma de
    matrices bidimensionales.</p>
    <p>Las características de los deques implementados en la STL pueden
    resumirse en: Acceso aleatorio; mecanismo eficiente de
    inserción al principio o al final.</p>
  </td>
  </tr>
  <tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>string</strong></td>
  <td bgcolor="#FFFFFF">Contenedor de caracteres adaptado a operaciones con cadenas de caracteres.</td>
  </tr>
  <tr>
  <td width="90" valign="top" bgcolor="#FFFFFF" colspan="2"><b>Asociaciones</b></td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>set</strong></td>
  <td bgcolor="#FFFFFF">Como el resto de contenedores
    asociativos, esta forma de contenedor mantiene los
    elementos en orden. Dispone de mecanismos eficientes para inclusión,
    inserción y eliminación de elementos, y soporta claves únicas (solo
    puede existir un miembro con una clave determinada).</td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>multiset</strong></td>
  <td bgcolor="#FFFFFF">Versión del anterior que permite la existencia de claves duplicadas. Es decir, distintos elementos
  dentro del conjunto pueden responder a la misma clave.</td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>bitset</strong></td>
  <td bgcolor="#FFFFFF">Contenedor de bit más orientado al tamaño que hacia el tipo de contenido. Permite almacenar
    secuencias de bits de tamaño fijo. No existen iteradores para
    reccorrerlas, y sus elementos se acceden utilizando el operador
    subíndice <span style="background-color: #FFFF00">[ ]</span>.
    <p>Se dispone de varias funciones para realizar con ellos operaciones
    de bits (<img border="0" src="./Contenedores_files/Ico_hoja.gif" width="16" height="16"> <a href="http://www.zator.com/Cpp/E4_9_3.htm">4.9.3</a>)</p>
  </td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>map</strong></td>
  <td bgcolor="#FFFFFF">Como el resto de estructuras asociativas, el <b>map</b> mantiene sus
    elementos ordenados. Se caracteriza porque sus miembros son
    pares de valores que pueden ser de tipos distintos. Uno de ellos, el que actúa como clave para el índice
    ("Key-value"), puede ser de cualquier tipo, a condición de
    que sus elementos puedan ser ordenados según un criterio (por defecto
    se utiliza el operador <b><span style="background-color: #FFFF00">&lt;</span></b>).
    <p>Permite claves únicas. Es decir, que solo puede existir un
    miembro para cada clave. Dispone de mecanismos de inserción y borrado muy eficientes y no existe límite de tamaño. La
    estructura se encarga de crecer y disminuir en concordancia con las
    necesidades de sus miembros. Permite el operador <span style="background-color: #FFFF00">[<sup>
    </sup>]</span> subíndice para los elementos de la clave así como
    otras técnicas de acceso.</p>
    <p>Estas estructuras de datos recibe también los nombres de diccionarios, tablas y matrices
    asociativas, en referencia a que pueden considerarse como dos
    matrices del mismo número de elementos, en las que existe una
    relación entre cada miembro de una con otro miembro de la otra.&nbsp;
    Una de las matrices (que actúa de índice) estaría ordenada según su contenido.</p>
  </td>
  </tr><tr>
  <td width="90" valign="top" bgcolor="#FFFFFF"><strong>multimap</strong></td>
  <td bgcolor="#FFFFFF">En todo igual que el anterior pero permitiendo además claves duplicadas. Es decir, que una misma clave pueda
    estar asociada a dos "valores" distintos.</td>
  </tr>
  </tbody></table>

  <p>&nbsp;</p>

<table border="0" cellpadding="5" class="bg0"><tbody><tr>
  <td width="18%" valign="top"><b><a name="Adaptadores">Adaptador</a></b></td>
  <td width="83%"><b>Características</b></td>
  </tr><tr>
  <td width="18%" valign="top" bgcolor="#FFFFFF"><strong>queue</strong></td>
  <td width="83%" bgcolor="#FFFFFF">Contenedor tipo cola FIFO que permite
  inserciones al final y eliminaciones al principio.</td>
  </tr><tr>
  <td width="18%" valign="top" bgcolor="#FFFFFF"><strong>priority queue</strong></td>
  <td width="83%" bgcolor="#FFFFFF">Este contenedor dispone de mecanismos
  eficientes para acceso y eliminación de grandes valores.</td>
  </tr>
</tbody></table>
<br>

<div class="foot"><a href="http://www.zator.com/Cpp/E5_1_1.htm#TOP"><img alt="" border="0" src="./Contenedores_files/arrow_btt.gif" width="9" height="5">&nbsp; Inicio</a></div>
</div>
<div class="top2">
<script type="text/javascript"><!--
google_ad_client = 'pub-3633041490650355';
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = '728x90_as';
google_ad_type = 'text_image';
google_ad_channel ='';
google_color_border = 'DDAAAA';
google_color_bg = 'ECF8FF';
google_color_link = '0033FF';
google_color_url = '0033FF';
google_color_text = '000000';
//--></script>
<script type="text/javascript" src="./Contenedores_files/show_ads.js.descarga">
</script><ins id="aswift_2_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><ins id="aswift_2_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><iframe width="728" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;" src="./Contenedores_files/saved_resource(2).html"></iframe></ins></ins>
</div>
</td></tr></tbody></table>
<div id="footer"><table border="0" width="100%" cellpadding="2"><tbody><tr><td>|<a href="http://www.zator.com/Cpp/E_Ce.htm">Índice</a>|</td>
<td>Copyright © 1990-2016 Zator Systems.</td>

</tr></tbody></table></div></div></body></html>